/////////////////////////////////////////////////////////////////////////

si implementi l’overloading dello operatore membro “()” (function call) 
per la classe A e lo si utilizzi nel main. L’operatore deve prevedere due 
parametri formali INTERI i1 e i2 e restituire la SOTTOSTRINGA di str 
formata dai caratteri presenti in str dall’indice i1 all’indice i2.
__________________
dentro la classe A
--------------------------------------|
string operator()(int i1, int i2){   
        string tmp="";               
        for(int i=i1; i<i2; i++)     
			tmp+=str[i]; 
        return tmp;                  
}                                    
--------------------------------------|
_________
nel main:
--------------------------------------|
cout<<"Punto III:"<<endl; 	      
	                              
	int a=1, b=3;                 
	string test=(*vett[0])(a, b); 
	cout<<test;                   
--------------------------------------|

//////////////////////////////////////////////////////////////////////////

si implementi l’overloading dello operatore membro “[]” per la classe A 
(madre) e lo si utilizzi nel main in una istruzione di assegnamento.
_______________________
nella classe A (madre):
------------------------------------|
double& operator [](const int i) {
	return ptr[i];
}
------------------------------------|
_________
nel main:
-----------------------------|
cout << "Punto III:" << endl;
(*vett[5])[0] = 1.1;
cout << *vett[5] << endl;
-----------------------------|

//////////////////////////////////////////////////////////////////////////

si implementi l’overloading dello operatore membro “[]” per la CLASSE B 
e lo si utilizzi nel main in una istruzione di assegnamento
_______________
nella classe B:
----------------------------|
int& operator [] (int i) {
	return ptr[i];
}
----------------------------|
_________
nel main:
----------------------------------------------|
cout << "Punto III:" << endl;
	if (typeid(*vett[2])==typeid(B)) {
		(*(B*)(vett[2]))[0] = 7; 
		cout << (*(B*) (vett[2]))[0];
	}
----------------------------------------------|

//////////////////////////////////////////////////////////////////////////

si visualizzi la stringa concatenazione di tutte le stringhe restituite 
da g('h') per tutti gli oggetti di tipo C;
________
nel main
------------------------------------------------------|
C* myObj;                                             
	for(int i=0; i<DIM; i++){                     
		myObj=dynamic_cast<C*>(vett[i]);      
		if(myObj!=NULL) cout<<myObj->g('h');  
	}                                             
	cout<<endl<<endl;                             
------------------------------------------------------|

//////////////////////////////////////////////////////////////////////////

si calcoli il MINIMO ed il MASSIMO valore v(50) per tutti gli oggetti della 
collezione, e la MEDIA dei valori g(5) per per tutti gli oggetti di tipo 
C<double>;

//se la classe non è Template, levare le angolari <>\\
//se chiede gli elementi di tutta la collezione, levare l'if (typeid ecc)\\

----------------------------------------------------------------------|
cout << "Punto II:"<<endl;
	double min = vett[0]->v(50);
	double max = -1;
	double sum = 0.0;
	for(int i=0;i<DIM;i++){
		if(max <= vett[i]->v(50)) max = vett[i]->v(50);
		if(min >= vett[i]->v(50)) min = vett[i]->v(50);
		if(typeid(*vett[i]) == typeid(C<double>)) {
			sum += ((C<double>*) vett[i])->g(5);
		}
	}
	cout << "massimo valore v(50) = " << max << endl;
	cout << "minimo valore v(50) = " << min << endl;
	cout << "media valori g(5) C<double> = " << sum/DIM << endl;
----------------------------------------------------------------------|

//////////////////////////////////////////////////////////////////////////

si calcoli il MASSIMO valore foo(3) per tutti gli oggetti della collezione 
e la MEDIA dei valori g(5) per per tutti gli oggetti di tipo C<double>;


cout << "Punto II:"<<endl;
	double max = -1;
	double sum = 0.0;
	for(int i=0;i<DIM;i++){
		if(max <= vett[i]->foo(3)) max = vett[i]->foo(3);
		if(typeid(*vett[i]) == typeid(C<double>)) {
			sum += ((C<double>*) vett[i])->g(5);
		}
	}
	cout << "massimo valore foo(3) = " << max << endl;
	cout << "media valori g(5) C<double> = " << sum/DIM << endl;


//////////////////////////////////////////////////////////////////////////

OVERLOADING BASE:

_________________________
fuori dalla classe madre:
-------------------------------------------|
ostream& operator<<(ostream& os, A& obj){ 
	return obj.put(os);               
}                                         
-------------------------------------------|
_______________________
dentro la classe madre:
---------------------------------------------|
virtual ostream& put(ostream& os){
	os<<typeid(*this).name()<< e c c ;
}
---------------------------------------------|
_______________________
dentro le altre classi:
------------------------------|
ostream& put(ostream& os){   
	A::put(os);
	os << e c c ;
	return os; 
}                            
------------------------------|
__________
nel main:
---------------------------------|
cout << "Punto I:"<< endl;
for(int i=0;i<DIM;i++){
      	cout<<i<<")"<<*vett[i];
}
---------------------------------|

//////////////////////////////////////////////////////////////////////////

Generazione casuale:

_________________________
tra due numeri int a e b:                                 

------------------------------------|
vec[i] = rand() % (b - a + 1) + a
------------------------------------|

__________________________
numeri compresi tra 0 e 1:                                

---------------------------------------|
double r = rand() / (RAND_MAX * 1.0);
---------------------------------------|
oppure
------------------------------------------|
double r = ((double) rand()) / RAND_MAX;
------------------------------------------|

//////////////////////////////////////////////////////////////////////////

Arrotondamento all'intero più vicino:
-----------------------|
y = floor(XXX+0.5);
-----------------------|